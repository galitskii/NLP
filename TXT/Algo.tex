\documentclass[a4paper,12pt]{article} % добавить leqno в [] для нумерации слева

%%% Работа с русским языком
\usepackage{cmap}					% поиск в PDF
%\usepackage{mathtext} 				% русские буквы в фомулах
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage[left=20mm,right=20mm,top=20mm,bottom=20mm]{geometry}
%%% Дополнительная работа с математикой
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} % AMS
\usepackage{icomma} % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление

%% Номера страниц
\pagestyle{plain}

%% Гиперссылки
\usepackage[colorlinks,urlcolor=blue]{hyperref}

%% Красная строка
\usepackage{indentfirst}
\setlength{\parindent}{1cm}

%% Номера формул
\mathtoolsset{showonlyrefs=true} % Показывать номера только у тех формул, на которые есть \eqref{} в тексте.

%% Шрифты
\usepackage[scaled]{helvet} % Шрифт
\usepackage{mathrsfs} % Красивый матшрифт

%% Свои команды
\DeclareMathOperator{\sgn}{\mathop{sgn}}

%% Свои теоремы
\theoremstyle{definition}
\def\proofname{Доказательство}
\newtheorem{Def}{Определение}
\newtheorem{T}{Задача}
\newtheorem{E}{Пример}
\theoremstyle{plain}
\newtheorem{Lem}{Лемма}
\newtheorem{R}{Замечание}
\newtheorem{Cl}{Утверждение}
\newtheorem{Cr}{Следствие}
\newtheorem{Th}{Теорема}
\newtheorem{A}{Аксиома}

%% Перенос знаков в формулах (по Львовскому)
\newcommand*{\hm}[1]{#1\nobreak\discretionary{}
	{\hbox{$\mathsurround=0pt #1$}}{}}

%% Комментарии
\usepackage{comment}

%% Алгоритмы
\usepackage{algorithm}
\usepackage{algpseudocode}

%% Работа с картинками
\usepackage{graphicx}
\graphicspath{{../img/}}
\usepackage{wrapfig} % Обтекание рисунков и таблиц текстом
\usepackage{caption}

%% Работа с таблицами
\usepackage{array,tabularx,tabulary,booktabs}
\usepackage{longtable}  % Длинные таблицы
\usepackage{multirow} % Слияние строк в таблице

%% Переопределение команд
\renewcommand{\ge}{\geqslant}
\renewcommand{\le}{\leqslant}

\title{Обработка запятых}
\author{Галицкий Борис Васильевич}


\begin{document}
\maketitle

\subsection*{Описание алгоритма}

Запятые могут участвововать как разделители частей одного простого предложения, так и как разделители простых предложений в составе сложного. Таким образом, они могут как влиять, так и не влиять на согласование числа в предложении.

Будем считать, что на вход подаётся правильное с точки зрения орфографии и пунктуации предожение (задачи проверки орфографии и пунктуации были успешно решены, например, корпорацией Microsoft). 

Согласно нашей \textbf{\textit{гипотезе}}, можно разработать систему правил, позволяющую обработать все запятые, возможно, упростив предложение (проверив во время упрощения согласование единственного и множественного числа в упрощаемых частях). При этом, единственное и множественное число в исходном предложении будут согласованы тогда и только тогда, когда они будут согласованы в упрощённом предложении.

\textbf{\textit{Ключевые этапы}} реализации:
\begin{enumerate}
	\item Формализация правил, когда запятые влияют на согласование единственного и множественного числа.
	\item Применение данной системы правил для идентификации запятых, влияющих на согласование единственного и множественного числа. Упрощение предложения на основе этой системы правил (с проверкой согласования единственного и множественного числа в частях предложения).
	\item Замена оставшихся запятых на точки (разбиение предложения на части без запятых, к каждой из которых можно применить уже реализованный алгоритм проверки согласования единственного и множественного числа в предложении без запятых).
\end{enumerate}

Данная задача в рамках нашей работы рассматривается только для существительных, местоимений, инфинитивов и личных глаголов. 

Одним из важных случаев, когда запятые влияют на согласование единственного и множественного числа, являются перечисления. В них используются союзы <<И>> или <<ИЛИ>>. Однако, уже в самом начале возникают проблемы: \begin{itemize}
	\item Cлова какой части речи перечисляются? 
	\item Какие слова в этой части предложения являются зависимыми?
	\item А если одним из перечисляемых объектов является словосочетание, нет ли там ошибки в согласовании числа?
\end{itemize}
Предложенный нами алгоритм даст ответы на эти вопросы.

\subsection*{Перечисление инфинитивов}

Как было сказано выше, существует проблема идентификации: слова какой части речи перечисляются? Итак, для начала рассмотрим случаи, когла перечисляются инфинитивы.

Для начала находим союз <<И>> или <<ИЛИ>>. Дальше смотрим на операнд слева. Если имеет место перечисление инфинитивов, то могут быть следующие варианты:\begin{itemize}
	\item инфинитив: <<Он любил есть, пить и танцевать>>.
	\item инфинитив + существительное: <<Он любил есть, пить сок и танцевать>>.
	\item инфинитив + существительное + существительное: <<Они могли понимать его, оценить игру слов и сделать выводы>>.
	\item инфинитив + местоимение: <<Он мог гордится ими, корить себя и винить друзей>>.
	\item инфинитив + инфинитив + существительное: <<Он мог любить свободу, любить делать добро и любить себя>>.
\end{itemize}

Определив, что это точно одна из данных конструкций, \begin{enumerate}
	\item Проверим в ней согласование числа.
	\item Проверим в правом операнде согласование числа.
	\item Внутри текущего предложения в цикле, двигаясь влево, будем искать запятые и соответствующие конструкции, тем самым определив границы фрагмента с перечислением инфинитивов.
\end{enumerate}

Если оказалось, что в какой-то из частей не согласовано время, то возвращаем значение <<N>>~--- не согласовано.

Если же на данном этапе всё корректно, то фрагмент, содержащий перечисление инфинитивов, заменяем на инфинитив (мы решили заменять перечисление инфинитивов на <<знать>>). Так, в результате работы описанного алгоритма предложение <<Они могли понимать его, оценить игру слов и сделать выводы>> будет преобразовано в предложение <<Они могли знать>>.

\subsection*{Перечисление личных глаголов}

Как и в ситуации с инфинитивами, сначала ищем союз <<И>> или <<ИЛИ>>, затем смотрим на операнд слева. Если имеет место перечисление личных глаголов, то возможны следующие варианты:\begin{itemize}
	\item личный глагол: <<Он пришёл, увидел и победил>>.
	\item личный глагол + существительное: <<Он купил дом, посадил дерево и вырастил сына>>.
	\item личный глагол + инфинитив: <<Он учил, любил учиться и хотел научить>>.
	\item личный глагол + инфинитив + существительное: <<Он мечтал построить дом, собирался посадить дерево и хотел найти клад>>.
	\item личный глагол + местоимение: <<Он ценил его, жалел себя и ненавидел их>>.
	\item личный глагол + инфинитив + местоимение: <<Он хотел увидеть её, собирался жалеть себя и видел их>>.
	\item личный глагол + существительное + существительное: <<Он услышал тебя, оценил игру слов и сделал выводы>>.
	\item личный глагол + местоимение + существительное + существительное: <<Он знал его, оценил его игру слов и сделал выводы>>.
\end{itemize}
Определив, что это точно одна из данных конструкций, \begin{enumerate}
	\item Проверим в ней согласование числа.
	\item Проверим в правом операнде согласование числа.
	\item Внутри текущего предложения в цикле, двигаясь влево, будем искать запятые и соответствующие конструкции, тем самым определив границы фрагмента с перечислением инфинитивов.
\end{enumerate}

Если оказалось, что в какой-то из частей не согласовано время, то возвращаем значение <<N>>~--- не согласовано. Здесь, в отличие от инфинитивов, нужно проверять, что перечисляются глаголы только единственного или только множественного числа.

Если же на данном этапе всё корректно, то фрагмент, содержащий перечисление инфинитивов, заменяем на личный глагол (мы решили заменять перечисление инфинитивов на <<знал>> или <<знали>> в зависимости от того, личные глаголы единственного или множественного числа перечисляются). Так, в результате работы описанного алгоритма предложение <<Он хотел увидеть её, собирался жалеть себя и видел их>> будет преобразовано в предложение <<Он знал>>.

\begin{R}
	Пока наша задача заключается лишь в согласовании числа, потому вполне может получиться упрощённое предложение вида <<Она знал>>. Однако, в данном случае оба слова в единственном числе, потому ошибки в согласовании числа нет.
\end{R}


\begin{algorithm}
\caption{Добавление пробелов между знаками пунктуации}
\begin{algorithmic}[1]
\Function{space}{str1}
\State str2 $\gets $ <<>> \Comment{В этой переменной будет храниться преобразованная строка}
\State l = len(str)
\For{$i \in \{1, 2, \ldots, l\}$} 
\If{str1$[i] \in \{$<<.>>; <<,>> $\}$  }
\State str2 $\gets$ str2 + << >>
\EndIf
\State str2 $\gets$ str2 + str1$[i]$
\EndFor
\State\Return str2
\EndFunction
\end{algorithmic}
\end{algorithm}
\newpage
\begin{algorithm}
	\caption{Обработка запятых}
	\begin{algorithmic}[1]
		\Function{comma}{l} \Comment{l~--- подготовленная строка}
		\State l $\gets$ l.split()
		\State llen $\gets$ len(l) \Comment{llen~--- длина списка l}
		\State h $\gets$ --1 \Comment{h~--- индекс начала заменяемой части}
		\State t $\gets$ --1 \Comment{t~--- индекс конца заменяемой части}
		\While{'и' $ \in l$}
		\State id1 $\gets$ l.index('и') \Comment{в id1 хранится индекс вхождения 'и'}
		\If{l[id1 -- 2] = ','}
		\State res1 $\gets$ l[id1 -- 1].(pos, singular, cow) \Comment{res1 содержит часть речи, число и падеж слова}
		\For{$i \in$ res1}
		\State part = i.pos \Comment{Записываем в part часть речи}
		\State h $\gets $ id1 -- 1 \Comment{Левая граница заменяемого перечисления}
		\State t $\gets$ id1 \Comment{Правая граница заменяемого перечисления}
		\If{part = '6'} \Comment{Обработка перечисления инфинитивов}
		\If{id1 + 1 $\le$ llen}
		\State res2 $\gets$ l[id1 + 1].(pos, singular, cow) \Comment{Анализируем слово, расположенное следом за 'и'}
		\If{res2.pos = part} \Comment{Если оно оказалось инфинитивом}
		\State t $\gets$ id1 + 1
		\EndIf
		\State idpr $\gets$ id1 -- 2 \Comment{Индекс потенциальной запятой}
		\State idd $\gets$ False \Comment{Индикатор перечисления}
		\While{idpr $\ge$ 0}\Comment{Пока не дошли до начала слова}
		\If{l[idpr] = ','}
		\State res2 $\gets$ l[idpr + 1].(pos, singular, cow)
		\If{res2.pos = part}
		\State l[idpr] $\gets$ <<`>>\Comment{Заменяем <<,>> на <<'>>, чтобы дальше не находить эту запятую}
		\State h $\gets$ idpr \Comment{Сдвигаем <<голову>> заменяемой части}
		\State idpr $\gets$ idpr -- 2
		\State idd $\gets$ True
		\EndIf
		\EndIf
		\EndWhile
		\EndIf
		\EndIf
		\EndFor
		\EndIf
		\EndWhile
		\EndFunction
		\algstore{bkbreak}
		 \end{algorithmic}
	\end{algorithm}
 \newpage
\begin{algorithm}
	\caption{Пример алгоритма}\label{alg:Examples}
	\begin{algorithmic}[1]
		
		\algrestore{bkbreak}
		\State l
	\end{algorithmic}
\end{algorithm}
\begin{comment}


\begin{algorithm}
	\caption{Обработка запятых}
	\begin{algorithmic}[1]
		\Function{comma}{строка $l$}
		\State l $\gets$ l.split() \Comment{получаем список из строки, разбивая по пробелам}
		\If{'и' присутствует в списке l}
		\State id = l.index('и') \Comment{индекс вхождения первой буквы 'и' в список}
		\State part = '
		\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\end{comment}
\end{document}
