\documentclass[main]{subfiles}





\begin{document}

\subsection{Подготовительный этап}
На вход программе подаётся предложение, состоящее из существительных, местоимений, личных глаголов или (и) инфинитивов (с, возможно, перечислением инфинитивов или личных глаголов с зависимыми словами, принадлежащим указанным частям речи). 

Полученное предложение передаётся функции space(), которая преобразует считанную строку в список. Механизм её работы описывает алгоритм \ref{alg1}.

\begin{algorithm}
	\caption{-- Предварительная обработка входных данных}\label{alg1}
	\begin{algorithmic}[1]
		\Function{space}{str1}
		\State str1 $\gets$ str1.lower() \Comment{Приводим полученную строку к нижнему регистру}
		\State str2 $\gets $ <<>> \Comment{В этой переменной будет храниться преобразованная строка}
		\State l $\gets$ len(str1)
		\For{\textbf{from} $i=0$ \textbf{to} $l - 1$} 
		\If{str1$[i] \in \{$<<.>>; <<,>> $\}$  }
		\State str2 $\gets$ str2 $+$ << >>
		\EndIf
		\State str2 $\gets$ str2 $+$ str1$[i]$
		\EndFor
		\If{str2[len(str2) $- 1$] $=$ << >>} \Comment{Если последним элементом полученного списка оказался пробел}
		\State str2 $\gets$ str2[ : len(str2) $- 1$] \Comment{Отбрасываем этот пробел}
		\EndIf
		\State\Return str2.split() \Comment{Возвращаем список, полученный из строки str2 разбиением её по пробелам}
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Таким образом, функция space() возвращает список, состоящий из слов и знаков препинания исходной строки.

\subsection{Обработка предложения}

Итак, как было сказано выше, проверка согласования единственного и множественного числа в русском языке~--- процесс сложный: нужно учесть много критериев. 

В основе предложенного нами подхода лежит гипотеза, согласно которой одно и то же предложение являться и не являться ошибочным одновременно с точки зрения согласования единственного и множественного числа не может. 

Также считаем, что в предложении нет орфографических, пунктуационных и др. ошибок, поскольку данная задача была успешно решена, например, компанией LanguageTooler GmbH \cite{langt}.

Нами было принято решение декомпозировать задачу. 

Для начала (при наличии перечислений инфинитивов или личных личных глаголов) предложение упрощается: перечисление мы заменяем на инфинитив или личный глагол соответственно (параллельно проверяя, что внутри заменяемой части нет ошибок в согласовании единственного и множественного числа). Если же перечисления не обнаружено, сразу переходим к следующему этапу.

Далее проверяем предложение без перечислений при помощи разработанной нами системы правил. 

Согласно теореме Гёделя о неполноте, формальная арифметика либо противоречива, либо неполна \cite{forms}. Чтобы избежать противоречивости разработанной системы, мы включили лишь те правила, которые встречаются на практике, а не перебрали все возможные комбинации используемых нами параметров.

\subsubsection{Упрощение предложения}
Под упрощением мы будем понимать замену перечисления инфинитивов или личных глаголов одиночным инфинитивом или личным глаголом. 

За упрощение предложения отвечает функция comma(), которая принимает на вход список, полученный из исходного предложения при помощи функции space(), описанной выше; а возвращает список, в котором упрощённое предложение. Механизм работы функции comma() описывает алгоритм \ref{alg2}.

\begin{algorithm}
	\caption{-- Обработка перечислений}\label{alg2}
	\begin{algorithmic}[1]
		\Function{comma}{l} \Comment{l~--- подготовленная строка в виде списка}
		\If{<<и>> \textbf{in} l}
		\State part $\gets [$ $]$ \Comment{Список значений параметра <<часть речи>> для данного слова (изначально пустой)}
		\State left $\gets (-1)$
		\State right $\gets (-1)$\Comment{Левая и правая границы заменяемого участка, изначально инициализируем невозможными значениями: $(-1)$}
		\State llen $\gets $len(l) \Comment{Длина исходного списка}
		\State id1 $\gets$ l.index(<<и>>)\Comment{Записываем индекс <<и>> в списке} 
		\algstore{bkbreak}
	\end{algorithmic}
\end{algorithm}
Для начала инициализируем переменные, затем находим индекс вхождения <<и>> в список (при условии, что в списке есть <<и>>).

\begin{algorithm}
	\caption{-- Продолжение алгоритма \ref{alg2}}\label{alg3}
	\begin{algorithmic}[1]
		\algrestore{bkbreak}
				\If{llen $>$ id1 $+ 1$}
		\State resp1 $\gets$ l[id1 $+ 1$].[pos, singugar, cow] \Comment{Варианты интерпретации слова, стоящего за <<и>>}
		\EndIf
		\If{llen $>$ id1 $+ 2$}
		\State resp2 $\gets$ l[id1 $+ 2$].[pos, singugar, cow]
		\EndIf	
		\If{llen $>$ id1 $+ 3$}
		\State resp3 $\gets$ l[id1 $+ 3$].[pos, singugar, cow] 
		\EndIf
		\If{llen $>$ id1 $+ 4$}
		\State resp4 $\gets$ l[id1 $+ 4$].[pos, singugar, cow]
		\EndIf
		\If{id1 $-1 \ge 0$}
		\State resl1 $\gets$ l[id1 $-1$].[pos, singugar, cow]
		\EndIf
		\If{id1 $-2 \ge 0$}
		\State resl2 $\gets$ l[id1 $-2$].[pos, singugar, cow]
		\EndIf
		\If{id1 $-3 \ge 0$}
		\State resl3 $\gets$ l[id1 $-3$].[pos, singugar, cow]
		\EndIf
		\If{id1 $-4 \ge 0$}
		\State resl1 $\gets$ l[id1 $-4$].[pos, singugar, cow]
		\EndIf
		\If{id1 $-5 \ge 0$}
		\State resl5 $\gets$ l[id1 $-5$].[pos, singugar, cow]
		\EndIf
		\If{id1 $-6 \ge 0$}
		\State resl6 $\gets$ l[id1 $-6$].[pos, singugar, cow]
		\EndIf
		\If{id1 $+1 <$ llen}
		\For{\textbf{from} $i=0$ \textbf{to} len(resp1)}
		\If{resp1$[i][0]=$<<6>>} \Comment{Слово оказалось инфинитивом}
		\State part$\gets$ <<6>>
		\State right $\gets$ id1 $+1$
				\EndIf
					\EndFor
					\If{right$=(-1)$}\Comment{Если же это не инфинитив}
					\For{\textbf{from} $i=0$ \textbf{to} len(resp1)}
					\If{resp1$[i][0]=$<<5>>}\Comment{Слово оказалось инфинитивом}
					\State right $\gets$id1$ + 1$ 
					\State part $\gets$ <<5>>
					\State sng $\gets $l$[i][1]$ \Comment{В отличие от инфинитивов для личных глаголов важно число}
		\algstore{bkbreak}
	\end{algorithmic}
\end{algorithm}
\newpage
Таким образом, в результате исполнения блока \ref{alg3} будет определено, слова (словосочетания) какой части речи перечисляются (если в предложении присутствует перечисление с союзом <<и>>).

Заметим, что в случае перечисления с союзом <<и>> за союзом идёт слово той же части речи, что и остальные перечисляемые слова. Например: \textit{<<Он хотел \textbf{читать} книги, \textbf{рисовать} картины и \textbf{познавать} тайны мироздания>>}. Легко видеть, что в предложении перечисляются инфинитивы и в то же время после союза <<и>> идёт инфинитив <<познавать>>.
\begin{algorithm}
	\caption{-- Продолжение алгоритма \ref{alg3}}
	\begin{algorithmic}[1]
		\algrestore{bkbreak}
		\EndIf
		\EndFor
		\EndIf
							\EndIf
		\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\end{document}